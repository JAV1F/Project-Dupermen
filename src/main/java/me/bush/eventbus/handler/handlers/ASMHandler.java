package me.bush.eventbus.handler.handlers;

import me.bush.eventbus.annotation.EventListener;
import me.bush.eventbus.event.Event;
import me.bush.eventbus.handler.DynamicHandler;
import me.bush.eventbus.handler.Handler;
import me.bush.eventbus.util.Util;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

/**
 * Started: 11/23/2021
 *
 * @author me.bush & forge
 */
public class ASMHandler extends Handler {

    /**
     * Classloader used to define classes from byte arrays.
     */
    private static final ASMLoader loader = new ASMLoader();

    /**
     * Bytecode name of the interface class to implement.
     */
    private static final String handlername = Type.getInternalName(DynamicHandler.class);

    /**
     * Bytecode descriptor of the interface method to override.
     */
    private static final String methodname = Type.getMethodDescriptor(DynamicHandler.class.getDeclaredMethods()[0]);

    /**
     * Count of all listeners minus 1.
     */
    private static int listeners;

    /**
     * Caches virtual listeners to avoid costly recreation.
     */
    private static final ConcurrentHashMap<Method, DynamicHandler> listenercache = new ConcurrentHashMap<>();

    /**
     * The class created by asm that contains this listener's method.
     */
    private final DynamicHandler dynamicHandler;

    /**
     * Fast invocation style that Forge uses for event listeners. Uses {@link MethodVisitor} and {@link ClassWriter}.
     * NOT MY CODE!!!!!!!!!
     *
     * @param listener   A method with an {@link EventListener} annotation.
     * @param subscriber The object or class that the listener belongs to.
     * @param logger     The consumer to use for error messages.
     * @throws Exception If the class generated by createWrapper can't be instantiated.
     * @see Handler
     */
    public ASMHandler(Method listener, Object subscriber, Consumer<String> logger) throws Exception {
        super(listener, subscriber, logger);
        // Check cache before creating a new listener
        if (listenercache.containsKey(listener)) this.dynamicHandler = listenercache.get(listener);
        else {
            // Create static
            if (Modifier.isStatic(listener.getModifiers())) {
                this.dynamicHandler = (DynamicHandler) this.createWrapper(listener).newInstance();
            }
            // Create with object
            else
                this.dynamicHandler = (DynamicHandler) this.createWrapper(listener).getConstructor(Object.class).newInstance(subscriber);
            // Put new dynamic handler in cache
            listenercache.put(listener, this.dynamicHandler);
        }
    }

    @Override
    public void invoke(Event event) {
        // Invoke through the class generated by asm
        this.dynamicHandler.invoke(event);
    }

    /**
     * THIS IS NOT MY CODE! For now this is the same code forges bus uses.
     */
    public Class<?> createWrapper(Method method) {
        ClassWriter cw = new ClassWriter(0);
        boolean isStatic = Modifier.isStatic(method.getModifiers());
        String name = this.getUniqueName(method);
        String desc = name.replace('.', '/');
        String instType = Type.getInternalName(method.getDeclaringClass());
        String eventType = Type.getInternalName(method.getParameterTypes()[0]);
        cw.visit(50, 33, desc, null, "java/lang/Object", new String[]{handlername});
        cw.visitSource(".dynamic", null);
        if (!isStatic) {
            cw.visitField(1, "instance", "Ljava/lang/Object;", null, null).visitEnd();
        }
        MethodVisitor mv = cw.visitMethod(1, "<init>", isStatic ? "()V" : "(Ljava/lang/Object;)V", null, null);
        mv.visitCode();
        mv.visitVarInsn(25, 0);
        mv.visitMethodInsn(183, "java/lang/Object", "<init>", "()V", false);
        if (!isStatic) {
            mv.visitVarInsn(25, 0);
            mv.visitVarInsn(25, 1);
            mv.visitFieldInsn(181, desc, "instance", "Ljava/lang/Object;");
        }
        mv.visitInsn(177);
        mv.visitMaxs(2, 2);
        mv.visitEnd();
        mv = cw.visitMethod(1, "invoke", methodname, null, null);
        mv.visitCode();
        mv.visitVarInsn(25, 0);
        if (!isStatic) {
            mv.visitFieldInsn(180, desc, "instance", "Ljava/lang/Object;");
            mv.visitTypeInsn(192, instType);
        }
        mv.visitVarInsn(25, 1);
        mv.visitTypeInsn(192, eventType);
        mv.visitMethodInsn(isStatic ? 184 : 182, instType, method.getName(), Type.getMethodDescriptor(method), false);
        mv.visitInsn(177);
        mv.visitMaxs(2, 2);
        mv.visitEnd();
        cw.visitEnd();
        return loader.define(name, cw.toByteArray());
    }

    /**
     * Would look like "ASMListener_1_SomeClass#someMethod".
     */
    private String getUniqueName(Method method) {
        return String.format(
                "%s_%d_%s",
                "ASMListener",
                listeners++,
                Util.formatMethodName(method)
        );
    }

    /**
     * Just so we can use a protected method in ClassLoader.
     */
    private static class ASMLoader extends ClassLoader {

        private ASMLoader() {
            super(ASMLoader.class.getClassLoader());
        }

        public Class<?> define(String name, byte[] data) {
            return this.defineClass(name, data, 0, data.length);
        }
    }
}
